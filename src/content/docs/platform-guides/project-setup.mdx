---
title: Setting Up a Self-Contained CI/CD Pipeline
description: This guide explains the philosophy behind self-contained CI/CD pipelines in 1FE.
sidebar:
  order: 2
---

import {
  FcEngineering,
  FcSettings,
  FcDeployment,
  FcWorkflow,
} from "react-icons/fc";

<div style={{ 
  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', 
  color: 'white', 
  padding: '2rem', 
  borderRadius: '12px', 
  marginBottom: '2rem',
  boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)'
}}>

### <FcEngineering style={{ display: 'inline', marginRight: '0.5rem', verticalAlign: 'middle' }} /> CI/CD Pipeline Overview

**Audience:** Platform teams setting up production CI/CD infrastructure for their organization.

This guide explains the philosophy of self-contained CI/CD and our implementation approach. We show how to take local development work and reliably deploy it to production environments using GitHub Actions as an example.

</div>

<div style={{ 
  background: '#f8f9fa', 
  padding: '1.5rem', 
  borderRadius: '8px', 
  border: '1px solid #e9ecef',
  marginBottom: '2rem'
}}>

### <FcSettings style={{ display: 'inline', marginRight: '0.5rem', verticalAlign: 'middle' }} /> What You'll Need

While this guide shows our specific implementation, you can adapt it to your needs. Here's what you'll typically need:

#### Essential Components & Our Implementation

• **Version Control:** To track code changes and enable collaboration (we use GitHub)

• **Build System:** Node.js for building and packaging (we use Node.js)

• **Deployment Target:** CDN or cloud storage for hosting (we use Akamai CDN)

• **Configuration Management:** Key-value stores for settings (we use Azure App Configuration)

• **CI/CD Automation:** CI/CD platforms for automation (we use GitHub Actions)

</div>

<div style={{ 
  background: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', 
  color: 'white', 
  padding: '1.5rem', 
  borderRadius: '8px', 
  marginBottom: '2rem'
}}>

## <FcDeployment style={{ display: 'inline', marginRight: '0.5rem', verticalAlign: 'middle' }} /> Setup Instructions

</div>

## 1. Repository Configuration

For a production setup, you need proper repository configuration to enable automated workflows. This involves setting up secrets, environments, and permissions for taking local development work to production.

### 1.1 Secrets Management

We use GitHub's secret management system to store sensitive credentials securely. All secrets are stored as repository secrets, never hardcoded in files.

**What it does:** Securely stores deployment credentials, API tokens, and connection strings that workflows need to authenticate with external services. This ensures sensitive information is never exposed in code or commit history.

**Examples of secrets we store:**

• SSH private keys for Akamai CDN deployment

• Azure App Configuration connection strings

• API tokens for external service authentication

• Database connection strings (if applicable)

**Resources:**

• [GitHub Secrets Documentation](https://docs.github.com/en/actions/security-guides/encrypted-secrets)

• [GitHub Variables Documentation](https://docs.github.com/en/actions/learn-github-actions/variables)

### 1.2 Environment Configuration

Each widget repository needs environment configuration to control deployment rules and approvals. This ensures proper oversight and prevents unauthorized deployments to production.

**What it does:** Creates separate deployment environments with different approval rules. Integration environments allow automated deployments for testing, while production environments require manual approval to ensure oversight and control over production releases.

**Setting up approval groups:**

• Create a GitHub team for production approvers (e.g., "Production Approvers")

• Add the team as required reviewers in the production environment

• Team members will receive notifications when production deployments need approval

• Only team members can approve production releases

**Resources:**

• [GitHub Environments Documentation](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment)

• [GitHub Teams Documentation](https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams)

• [Required Reviewers Documentation](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#required-reviewers)

### 1.3 Workflow Files in Widget Repositories

Our widget repositories contain the necessary CI/CD workflow files in the `.github/workflows/` directory:

:::tip[Widget Release Workflow]
**`widget-ci.yml`** - Main CI/CD pipeline for widget releases

• Triggers on pushes to main branch and pull requests

• Builds, tests, and deploys your widget to the appropriate environment

• Handles the complete release process from code to production
:::

:::caution[Widget Rollback Workflow]
**`rollback-widget.yml`** - Manual rollback workflow for reverting to previous widget versions

• Can be triggered manually when needed

• Allows you to quickly revert to a previous working version

• Useful for emergency situations or when issues are discovered in production
:::

:::important[Platform Integration]
These workflow files are pre-configured to work with the 1fe platform and call into the centralized CI/CD repository (`1fe-ci-cd`) for the actual pipeline logic.
:::

### 1.4 Template Workflow Files (1fe-ci-cd Repository)

The centralized `1fe-ci-cd` repository contains pre-built workflow files that handle different aspects of the CI/CD pipeline:

| File Name                             | Purpose                                                                   |
| ------------------------------------- | ------------------------------------------------------------------------- |
| `ci-widgets.yml`                      | Main orchestrator workflow - coordinates all build, test, and deploy jobs |
| `reusable-rollback-ci.yml`            | Handles rollback procedures with asset verification                       |
| `reusable-update-azure-config.yml`    | Updates configuration in external services                                |
| `reusable-widget-test-production.yml` | Production-specific test suite (lint, unit, contract, E2E)                |
| `reusable-widget-test.yml`            | Standard test suite for development and integration environments          |

### 1.5 Template Custom Actions (1fe-ci-cd Repository)

The centralized repository includes reusable actions for common CI/CD operations:

| Action Name            | Purpose                                                       |
| ---------------------- | ------------------------------------------------------------- |
| `check-cdn-asset`      | Verifies that assets are properly deployed and accessible     |
| `update-azure-config`  | Handles configuration updates in external services            |
| `widget-build`         | Builds the widget, calculates version, and archives artifacts |
| `widget-test-setup`    | Sets up the testing environment and dependencies              |
| `widget-upload-akamai` | Handles uploading build artifacts to deployment targets       |

**Note:** Our example uses specific cloud services, but you can adapt this to your preferred deployment platform. We link to official documentation rather than implementation details that can go stale quickly.

## 3. How We Use the Workflows

Our workflow files are present in the widget repository and work as follows:

### 3.1 Automatic Releases

• **`widget-ci.yml`** runs automatically when we:

• Push code to the main branch

• Create or update pull requests

• No manual intervention needed for normal releases. Deployment to integration is automated.

### 3.2 Manual Rollbacks

• **`rollback-widget.yml`** can be triggered manually when needed:

1. Go to the **Actions** tab in the GitHub repository

2. Select **"Rollback Widget"** from the workflow list

3. Click **"Run workflow"**

4. Enter the target version we want to rollback to

5. Select the environment (integration/production)

6. Click **"Run workflow"**

:::tip[When to Use Rollback]
We use the rollback workflow when:

• A production deployment has issues

• We need to quickly revert to a previous working version

• Emergency situations require immediate action
:::

## Our Complete Toolchain

Here's our specific implementation stack with all the tools and services we use:

<details>
<summary><strong>Our Implementation</strong></summary>

<div style={{ marginLeft: '1rem', marginTop: '0.5rem' }}>

**Core Platform:**

• **GitHub Actions** - CI/CD automation platform

• **GitHub Secrets** - Secure credential management

• **GitHub Environments** - Deployment environment management

**Deployment & CDN:**

• **Akamai CDN** - Content delivery and hosting

**Configuration Management:**

• **Azure App Configuration** - Version management and feature flags

**Development Tools:**

• **Node.js** - Build and test environment

• **Yarn** - Package management

• **TypeScript** - Development language

</div>

</details>

## Alternative Implementations

Our example uses GitHub Actions and specific cloud services, but you can implement the same philosophy with different tools:

### CI/CD Platforms

• **GitLab CI/CD:** [GitLab CI/CD Documentation](https://docs.gitlab.com/ee/ci/)

• **Bitbucket Pipelines:** [Bitbucket Pipelines Documentation](https://support.atlassian.com/bitbucket-cloud/docs/get-started-with-bitbucket-pipelines/)

• **Jenkins:** [Jenkins Documentation](https://www.jenkins.io/doc/)

### Deployment Platforms

• **AWS S3 + CloudFront:** [AWS S3 Documentation](https://docs.aws.amazon.com/s3/), [CloudFront Documentation](https://docs.aws.amazon.com/cloudfront/)

• **Google Cloud Storage + CDN:** [Google Cloud Storage Documentation](https://cloud.google.com/storage/docs)

• **Azure Blob Storage + CDN:** [Azure Storage Documentation](https://docs.microsoft.com/en-us/azure/storage/)

• **Vercel/Netlify:** [Vercel Documentation](https://vercel.com/docs), [Netlify Documentation](https://docs.netlify.com/)

### Configuration Management

• **AWS Parameter Store:** [AWS Systems Manager Parameter Store](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html)

• **HashiCorp Vault:** [Vault Documentation](https://www.vaultproject.io/docs)

• **Google Secret Manager:** [Google Secret Manager Documentation](https://cloud.google.com/secret-manager/docs)

The goal is to have a CI/CD system that moves with your code, is transparent to your team, and can be easily understood and modified as your needs change.

## Summary

Our CI/CD setup provides a self-contained, automated deployment pipeline that moves with your code. Here's what we've covered:

### What We've Set Up

• **Repository Configuration** - Secrets, environments, and workflow files
• **Automated Workflows** - Release and rollback processes
• **Centralized Templates** - Reusable CI/CD components
• **Complete Toolchain** - GitHub Actions, Akamai CDN, Azure App Configuration

### Key Benefits

• **Self-contained** - All pipeline logic stays with your code
• **Automated** - No manual intervention for normal releases
• **Secure** - Proper secret management and approval workflows
• **Flexible** - Can be adapted to different tools and platforms
• **Maintainable** - Clear documentation and modular design

### Next Steps

- [ ] Configure your widget repository with the required secrets and environments

- [ ] Ensure your team has proper access and approval permissions

- [ ] Test the automated release process in integration environment

- [ ] Familiarize yourself with the rollback workflow for emergency situations

This setup ensures your CI/CD pipeline is transparent, reliable, and can grow with your team's needs.
