---
title: Why 1fe?
description: Do we really need another FrontEnd standard?
---

There are already multiple standards and patterns set across the industry, and more so at a given organization. The point of 1fe is to not be the next standard, but to be a self-defined and distributed platform for to bring your organization's existing standards together and aligning on the best practices.

1fe, as the name suggests, implies 1-way to implement front end across your organization. This is not to say that 1fe is the only way to do front end, but it is the way that your organization has decided to do front end. This is a key distinction that allows for the flexibility of the platform to be extended and customized to fit your organization's needs.

1fe is **NOT** just a JS framework; it is a platform and set of Standards and best practices that can be implemented in any framework or library. The goal is to provide a consistent and predictable way to build and maintain front-end applications across your organization to allow:

- Isolated and independent sandboxed components.
- Micro front ends with micro repositories.
- Reduction of guest development.
- Consistent and predictable development.
- Maximize reuse across the organization.
- Simplify the onboarding process for new developers.
- Reduce the cognitive load of maintaining multiple standards.
- Increase the speed of development and deployment.
- Provide an unparalleled DX for developers.
- Abstract complexity away.
- Provide a separation between platform and product.
- Provide a clear path to upgrade and migrate applications.

### Who is 1fe for?

1fe is not built to be adopted by an individual, but rather a UI platform team at an organization. The goal is to provide an ecosystem that enables the team to build and maintain tooling, guidance, and standards that can be utilized by the rest of the organization without any effort or overhead. A few examples of the decisions that the 1fe team would make are:

**Code Authoring**

- What version of NodeJS to use for build/tooling?
- What version of TypeScript to use?
- What version of React to use?
- What ESLint rules to enable for strict / non-strict mode?

**Testing**

- What Unit Testing framework to use?
- What the centralized configuration for it looks like?

**Build**

- What bundler tool to use?
- What does the centralized configuration for it look like?
- How to handle CSS/SCSS/LESS?
- How to handle Images/Fonts?
- What libraries are common enough to be externalized (load once, cache forever)?

**Deployment**

> Abstracted away from product teams

- What CI/CD technologies to use?
- What CDN provider to use?
- How to bundle and deploy assets?
- What caching strategies to use?
- How to optimize assets for performance?

**Runtime**

- What authentication strategies to enable via configs?
- What routes to enable via configs per product?

**Utilities**

- What utility helper functions to make available out of the box?
- What UI logger to use?
- What error handling strategy to use?
- What analytics provider to use?
- What A/B testing and experimentation platform to use?
