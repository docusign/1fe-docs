---
title: "Step 1: Setting Up Shared Configurations"
description: Create centralized configurations that all widgets in your organization inherit
sidebar:
  order: 1
---

import {
  SlTarget,
  SlCheck,
  SlArrowRight,
  SlWrench,
  SlSettings,
} from "react-icons/sl";

The first step to taking platform ownership is establishing **shared configurations** that all widgets in your organization will inherit. This ensures consistency and makes it easy to update standards across your entire ecosystem.

## üéØ What You'll Accomplish

By the end of this step, you'll have:

<div class="prose">

- **Your own shared configuration package** - Centralized ESLint, TypeScript, and build settings
- **Automated publishing pipeline** - Changes propagate automatically to all widgets
- **Organization-wide consistency** - All teams follow the same standards without manual setup

</div>

## üîß Understanding the Base Config Pattern

1fe uses a **base configuration pattern** where common settings are published as npm packages and consumed by all widgets. This approach:

<div class="prose">

- **Centralizes standards** - ESLint rules, TypeScript configs, build settings all managed in one place
- **Enables easy updates** - Change a rule once, update everywhere by bumping a version
- **Reduces boilerplate** - Teams don't need to maintain complex configuration files
- **Enforces consistency** - No more configuration drift between teams

</div>

### Examining the Reference Implementation

Let's start by exploring how this is done in the reference implementation:

**Repository: [1fe-sample-widget-base-config](https://github.com/docusign/1fe-sample-widget-base-config)**

This repository demonstrates the pattern by providing:

```json title="package.json"
{
  "name": "@1fe/sample-widget-base-config",
  "version": "1.0.0",
  "main": "dist/index.js",
  "files": ["dist/"],
  "dependencies": {
    "@1fe/eslint-config": "^1.0.0",
    "@1fe/typescript-config": "^1.0.0"
  }
}
```

The package exports configuration objects that widgets can extend:

```typescript title="src/index.ts"
export { default as eslintConfig } from "./eslint.config";
export { default as tsConfig } from "./typescript.config";
export { buildConfig } from "./build.config";
```

## üèóÔ∏è Creating Your Own Shared Configuration Repository

### 1. Fork and Customize

The easiest approach is to fork the reference repository:

```bash
# Fork 1fe-sample-widget-base-config to your organization
git clone https://github.com/YOUR-ORG/your-org-widget-base-config.git
cd your-org-widget-base-config
```

### 2. Update Package Information

```json title="package.json" {2-4}
{
  "name": "@your-org/widget-base-config",
  "version": "1.0.0",
  "description": "Shared configuration for YOUR-ORG 1fe widgets",
  "repository": {
    "type": "git",
    "url": "https://github.com/YOUR-ORG/your-org-widget-base-config.git"
  }
}
```

### 3. Customize Configurations for Your Organization

**ESLint Configuration:**

```javascript title="src/eslint.config.js"
module.exports = {
  extends: ["@1fe/eslint-config"],
  rules: {
    // Add your organization-specific rules
    "@typescript-eslint/naming-convention": [
      "error",
      {
        selector: "interface",
        format: ["PascalCase"],
        prefix: ["I"], // Your org prefers I-prefixed interfaces
      },
    ],
    // Enforce your coding standards
    "max-len": ["error", { code: 120 }], // Your preferred line length
  },
};
```

**TypeScript Configuration:**

```json title="src/typescript.config.json"
{
  "extends": "@1fe/typescript-config/base.json",
  "compilerOptions": {
    "strict": true,
    "baseUrl": "./src",
    "paths": {
      "@your-org/*": ["../node_modules/@your-org/*"]
    }
  }
}
```

### 4. Publish Your Configuration Package

Set up automated publishing:

```yaml title=".github/workflows/publish.yml"
name: Publish Package
on:
  release:
    types: [published]
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: "18"
          registry-url: "https://registry.npmjs.org"
      - run: npm ci
      - run: npm run build
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

## ‚öôÔ∏è How 1fe CLI Uses Shared Configurations

When you run `@1fe/cli` commands, it automatically discovers and applies your shared configurations:

**Widget package.json:**

```json title="package.json"
{
  "devDependencies": {
    "@your-org/widget-base-config": "^1.0.0",
    "@1fe/cli": "^latest"
  }
}
```

**Build Process:**

1. `@1fe/cli` scans for base config packages in `node_modules`
2. Merges your organization's configurations with 1fe defaults
3. Applies the combined configuration during build and development

**Configuration Discovery:**

```typescript
// This happens automatically in @1fe/cli
const baseConfig = require("@your-org/widget-base-config");
const mergedConfig = {
  ...defaultConfig,
  ...baseConfig.buildConfig,
  // Your org's rules take precedence
};
```

## üéØ Why This Matters for Platform Teams

**Centralized Control:**

- Update linting rules across all widgets by publishing a new config version
- Enforce coding standards without requiring individual team changes
- Standardize build optimizations and performance settings

**Developer Experience:**

- Teams get pre-configured, tested setups out of the box
- No need to maintain complex configuration files per widget
- Automatic updates when teams upgrade the base config version

**Governance:**

- Platform team can enforce security policies, accessibility standards
- Consistent tooling versions across the entire organization
- Clear upgrade paths for breaking changes

## üîÑ Managing Configuration Updates

### Versioning Strategy

Use semantic versioning for your configuration packages:

```json title="package.json"
{
  "name": "@your-org/widget-base-config",
  "version": "2.1.0"
}
```

- **Major version** (2.x.x) - Breaking changes that require widget updates
- **Minor version** (x.1.x) - New rules or features, backward compatible
- **Patch version** (x.x.0) - Bug fixes and minor tweaks

### Communication Strategy

When updating configurations:

1. **Document changes** in CHANGELOG.md
2. **Announce updates** in team channels
3. **Provide migration guides** for breaking changes
4. **Gradually roll out** major version updates

### Example Configuration Evolution

```javascript title="eslint.config.js - v1.0.0"
module.exports = {
  extends: ["@1fe/eslint-config"],
  rules: {
    "prefer-const": "error",
  },
};
```

```javascript title="eslint.config.js - v2.0.0"
module.exports = {
  extends: ["@1fe/eslint-config"],
  rules: {
    "prefer-const": "error",
    // NEW: Enforce accessibility standards
    "jsx-a11y/alt-text": "error",
    "jsx-a11y/aria-props": "error",
  },
};
```

## üéØ Next Steps with Shared Configurations

Once your shared configuration is published:

1. **Update all widget repositories** to use your new base config
2. **Document configuration customization** guidelines for teams
3. **Set up monitoring** to track which widgets are using which config versions
4. **Plan upgrade strategies** for when you need to make breaking changes

## ‚úÖ Validation Checklist

Before moving to the next step, ensure:

<div class="prose">

- [ ] **Configuration package published** - Available in your npm registry
- [ ] **Automated publishing setup** - CI/CD pipeline publishes new versions
- [ ] **Documentation created** - Teams know how to use and customize configs
- [ ] **Migration path defined** - Process for updating widget repositories
- [ ] **Versioning strategy established** - Clear semantic versioning approach

</div>

## üëâ Next Step

With shared configurations in place, you now have centralized control over code quality and build standards. Next, we'll set up the CI/CD infrastructure that ensures all widgets deploy consistently and safely.

**‚Üí [Step 2: Setting Up CI/CD Repository](/tutorials/take-ownership/cicd-setup/)**

In the next step, you'll establish standardized deployment pipelines that all widget teams can adopt.

---

:::tip[Configuration Best Practices]
Start with conservative rules and gradually tighten standards as teams adapt. It's easier to add new rules than to remove ones that are causing friction.
:::