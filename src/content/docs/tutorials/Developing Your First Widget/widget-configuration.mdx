---
title: "Step 3: Understanding Widget Configuration"
description: Deep dive into widget configuration, contracts, and platform integration
sidebar:
  order: 3
---

import {
  SlTarget,
  SlCheck,
  SlArrowRight,
  SlWrench,
  SlSettings,
  SlDoc,
} from "react-icons/sl";

Understanding widget configuration is key to building flexible, maintainable widgets that integrate seamlessly with the 1fe platform. In this step, you'll learn about contracts, configuration files, and platform integration.

## üéØ What You'll Accomplish

By the end of this step, you'll understand:

<div class="prose">

- **Widget contracts** - How widgets define their interface with the platform
- **Configuration files** - The .1fe.config.ts file and its options
- **Platform integration** - How widgets connect with the 1fe ecosystem
- **Environment configuration** - Different settings for development, staging, and production

</div>

## üìã Widget Contracts: The Foundation

Widget contracts define the interface between your widget and the 1fe platform. They specify what props your widget expects and what it provides back to the platform.

### Understanding the Contract File

Let's examine and enhance your widget contract:

```typescript title="src/contract.ts"
// Basic widget props interface
export interface WidgetProps {
  // Required props
  widgetId: string;

  // Optional configuration props
  title?: string;
  theme?: "light" | "dark" | "auto";

  // Feature flags
  enableFeatures?: {
    advanced?: boolean;
    beta?: boolean;
  };

  // Data props
  initialData?: {
    user?: {
      id: string;
      name: string;
      role: string;
    };
    settings?: Record<string, any>;
  };

  // Event handlers
  onAction?: (action: string, data?: any) => void;
  onError?: (error: Error) => void;
}

// Widget capabilities - what your widget can do
export interface WidgetCapabilities {
  // Can the widget be resized?
  resizable: boolean;

  // Does it need authentication?
  requiresAuth: boolean;

  // What events does it emit?
  events: string[];

  // What platform utilities does it use?
  platformDependencies: string[];
}

// Complete widget contract
export interface WidgetContract {
  props: WidgetProps;
  capabilities: WidgetCapabilities;
}
```

### Implementing the Contract

Update your widget to use the enhanced contract:

```typescript title="src/app1.tsx"
import React, { useEffect, useState } from "react";
import { platformProps } from "@1fe/shell";
import { WidgetProps } from "./contract";

const MyWidget: React.FC<WidgetProps> = ({
  widgetId,
  title = "My Widget",
  theme = "light",
  enableFeatures = {},
  initialData,
  onAction,
  onError,
}) => {
  const [state, setState] = useState({
    loading: false,
    data: initialData || null,
  });

  useEffect(() => {
    // Initialize widget
    platformProps.utils.appLoadTime.end();
    console.log("Widget initialized:", { widgetId, theme });

    // Notify parent of initialization
    onAction?.("widget:initialized", { widgetId });
  }, [widgetId, onAction]);

  const handleFeatureClick = () => {
    if (enableFeatures.advanced) {
      onAction?.("feature:advanced", { timestamp: Date.now() });
    } else {
      console.log("Advanced features disabled");
    }
  };

  const handleError = (error: Error) => {
    console.error("Widget error:", error);
    onError?.(error);
  };

  return (
    <div
      style={{
        backgroundColor: theme === "dark" ? "#333" : "#fff",
        color: theme === "dark" ? "#fff" : "#333",
        padding: "20px",
        borderRadius: "8px",
        border: `2px solid ${theme === "dark" ? "#555" : "#ddd"}`,
      }}>
      <h1>{title}</h1>
      <p>Widget ID: {widgetId}</p>

      {initialData?.user && (
        <div>
          <h3>User Info:</h3>
          <p>Name: {initialData.user.name}</p>
          <p>Role: {initialData.user.role}</p>
        </div>
      )}

      <button
        onClick={handleFeatureClick}
        disabled={!enableFeatures.advanced}
        style={{
          backgroundColor: enableFeatures.advanced ? "#007bff" : "#ccc",
          color: "#fff",
          border: "none",
          padding: "10px 20px",
          borderRadius: "4px",
          cursor: enableFeatures.advanced ? "pointer" : "not-allowed",
        }}>
        Advanced Feature {enableFeatures.advanced ? "Enabled" : "Disabled"}
      </button>
    </div>
  );
};

export default MyWidget;
```

## ‚öôÔ∏è The .1fe.config.ts Configuration File

The `.1fe.config.ts` file is the central configuration for your widget's build process, dependencies, and deployment settings.

### Basic Configuration Structure

```typescript title=".1fe.config.ts"
import { defineConfig } from "@1fe/cli";

export default defineConfig({
  // Widget identification
  widget: {
    name: "my-first-widget",
    version: "1.0.0",
    entry: "src/app1.tsx",
    description: "My first 1fe widget for learning",
  },

  // Build configuration
  build: {
    target: "es2020",
    sourcemap: true,
    minify: process.env.NODE_ENV === "production",
  },

  // Development server settings
  devServer: {
    port: 8080,
    cors: true,
    hot: true,
  },

  // External dependencies (provided by the platform)
  externals: {
    react: "React",
    "react-dom": "ReactDOM",
    "@1fe/shell": "1fe.shell",
  },

  // Widget contract validation
  contract: {
    validate: true,
    strict: true,
  },
});
```

### Advanced Configuration Options

```typescript title=".1fe.config.ts (advanced)"
import { defineConfig } from "@1fe/cli";

export default defineConfig({
  widget: {
    name: "my-first-widget",
    version: "1.0.0",
    entry: "src/app1.tsx",
    description: "My first 1fe widget",

    // Widget metadata
    author: "Your Name",
    license: "MIT",
    tags: ["demo", "tutorial", "learning"],

    // Platform requirements
    platformVersion: "^2.0.0",
    requiredCapabilities: ["navigation", "storage"],
  },

  // Environment-specific configuration
  environments: {
    development: {
      apiBaseUrl: "http://localhost:3001/api",
      debug: true,
      analytics: false,
    },
    staging: {
      apiBaseUrl: "https://staging-api.company.com",
      debug: false,
      analytics: true,
    },
    production: {
      apiBaseUrl: "https://api.company.com",
      debug: false,
      analytics: true,
      performance: {
        budgets: {
          bundle: "100kb",
          initial: "50kb",
        },
      },
    },
  },

  // Asset handling
  assets: {
    // Copy static assets
    copy: [{ from: "src/assets", to: "assets" }],

    // Optimize images
    images: {
      optimize: true,
      formats: ["webp", "png"],
    },
  },

  // Testing configuration
  testing: {
    framework: "jest",
    coverage: {
      threshold: {
        statements: 80,
        branches: 80,
        functions: 80,
        lines: 80,
      },
    },
  },
});
```

## üîó Platform Integration

Understanding how your widget integrates with the 1fe platform is crucial for building effective widgets.

### Platform Utilities

Your widget has access to various platform utilities:

```typescript title="src/utils/platform.ts"
import { platformProps } from "@1fe/shell";

// Navigation utilities
export const navigation = {
  goToRoute: (route: string) => {
    platformProps.utils.navigation.navigate(route);
  },

  openModal: (modalId: string, props?: any) => {
    platformProps.utils.modal.open(modalId, props);
  },
};

// Logging utilities
export const logger = {
  info: (message: string, data?: any) => {
    platformProps.utils.logger.info(message, data);
  },

  error: (message: string, error?: Error) => {
    platformProps.utils.logger.error(message, error);
  },
};

// Storage utilities
export const storage = {
  get: (key: string) => {
    return platformProps.utils.storage.get(key);
  },

  set: (key: string, value: any) => {
    platformProps.utils.storage.set(key, value);
  },
};

// Event system
export const events = {
  emit: (event: string, data?: any) => {
    platformProps.utils.events.emit(event, data);
  },

  listen: (event: string, callback: Function) => {
    return platformProps.utils.events.on(event, callback);
  },
};
```

### Using Platform Utilities in Your Widget

```typescript title="src/app1.tsx (with platform integration)"
import React, { useEffect, useState } from "react";
import { WidgetProps } from "./contract";
import { logger, storage, events } from "./utils/platform";

const MyWidget: React.FC<WidgetProps> = ({
  widgetId,
  title = "My Widget",
  onAction,
}) => {
  const [visitCount, setVisitCount] = useState(0);

  useEffect(() => {
    // Log widget initialization
    logger.info("Widget initialized", { widgetId });

    // Load visit count from storage
    const count = storage.get(`${widgetId}:visitCount`) || 0;
    setVisitCount(count + 1);
    storage.set(`${widgetId}:visitCount`, count + 1);

    // Emit widget ready event
    events.emit("widget:ready", { widgetId });

    // Listen for platform events
    const unsubscribe = events.listen("platform:themeChanged", (theme) => {
      logger.info("Theme changed", { theme });
      onAction?.("theme:changed", theme);
    });

    return () => {
      unsubscribe();
    };
  }, [widgetId, onAction]);

  const handleSaveData = () => {
    const data = { timestamp: Date.now(), visitCount };
    storage.set(`${widgetId}:data`, data);
    logger.info("Data saved", data);
    onAction?.("data:saved", data);
  };

  return (
    <div style={{ padding: "20px" }}>
      <h1>{title}</h1>
      <p>Visit count: {visitCount}</p>

      <button onClick={handleSaveData}>Save Data</button>
    </div>
  );
};

export default MyWidget;
```

## üåç Environment Configuration

Different environments require different configurations. Here's how to handle environment-specific settings:

### Environment Detection

```typescript title="src/utils/environment.ts"
// Detect current environment
export const getEnvironment = (): "development" | "staging" | "production" => {
  if (typeof window === "undefined") return "development";

  const hostname = window.location.hostname;

  if (hostname === "localhost" || hostname.includes("local")) {
    return "development";
  }

  if (hostname.includes("staging") || hostname.includes("dev")) {
    return "staging";
  }

  return "production";
};

// Environment-specific configuration
export const getConfig = () => {
  const env = getEnvironment();

  const configs = {
    development: {
      apiBaseUrl: "http://localhost:3001/api",
      debug: true,
      analytics: false,
    },
    staging: {
      apiBaseUrl: "https://staging-api.company.com",
      debug: false,
      analytics: true,
    },
    production: {
      apiBaseUrl: "https://api.company.com",
      debug: false,
      analytics: true,
    },
  };

  return configs[env];
};
```

## üìö Configuration Reference

For complete configuration options, refer to the [1fe Configuration Reference](/reference/1fe-config-reference/). This documentation covers:

<div class="prose">

- **All configuration options** - Complete .1fe.config.ts API
- **Environment handling** - Best practices for multi-environment setup
- **Performance optimization** - Bundle size and runtime optimization
- **Advanced features** - Plugin system, custom transformations, and more

</div>

## ‚úÖ Validation Checklist

Before moving to the next step, ensure:

<div class="prose">

- [ ] **Widget contract** defined with proper TypeScript interfaces
- [ ] **Configuration file** updated with appropriate settings
- [ ] **Platform utilities** integrated into your widget
- [ ] **Environment detection** working for different deployment targets
- [ ] **Props validation** working in the playground

</div>

## üéâ Configuration Mastery!

You now understand the foundation of widget development - contracts, configuration, and platform integration. Your widget is properly structured and ready for production deployment.

## üëâ Next Step

Now that your widget is properly configured, let's learn how to build, test, and prepare it for deployment in your organization's infrastructure.

**‚Üí [Step 4: Building and Testing Your Widget](/tutorials/developing-your-first-widget/building-testing/)**

In the final step, you'll learn the complete build process, testing strategies, and how to prepare your widget for deployment.

---

:::tip[Configuration Best Practices]

- **Start simple** - Begin with basic configuration and add complexity as needed
- **Use TypeScript** - Strong typing prevents configuration errors
- **Environment-specific** - Always consider different deployment environments
- **Document contracts** - Clear interfaces make widgets easier to use and maintain
  :::
