---
title: 'Hosting Service Setup'
description: 'Deploy your 1FE application to production hosting services'
---

## Overview

Your 1FE application shell needs to be hosted on a reliable service that can handle user traffic and serve your application globally. This guide covers how to deploy your 1FE instance to production hosting services.

## Why You Need a Hosting Service

A hosting service provides:
- **Application shell hosting** - Serves your main 1FE application
- **Static file serving** - HTML, CSS, JS files for your shell
- **Global availability** - Ensures your app is accessible worldwide
- **SSL/TLS termination** - Secure HTTPS connections
- **Load balancing** - Handle traffic spikes and ensure reliability

### Azure Web App (Recommended for Enterprise)

**Why Azure Web App for 1FE:**
- Platform-as-a-Service (PaaS) with built-in CI/CD integration  
- Seamless integration with Azure ecosystem and enterprise services
- Built-in security, scalability, and monitoring features
- Support for custom domains and SSL certificates
- Continuous deployment from GitHub with automated workflows

This comprehensive guide provides step-by-step instructions for creating and configuring an Azure Web App that allows replication of the 1fe-demo setup.

#### Step 1: Introduction to Azure App Service

Azure App Service is a Platform-as-a-Service (PaaS) for hosting web applications, REST APIs, and mobile backends. It supports various programming languages and provides built-in features like continuous deployment, security, and scalability. A key component of an App Service is the App Service Plan, which defines the underlying compute resources (CPU, memory, storage) for your app.

**Official Documentation:** [Azure App Service Documentation](https://docs.microsoft.com/en-us/azure/app-service/)

#### Step 2: Create a New Web App

The first step is to create the core Web App resource.

**Setup Instructions:**

1. **Log in to the Azure Portal**
   - Navigate to [Azure Portal](https://portal.azure.com/)

2. **Create a New Web App Resource**
   - From the home page, click **+ Create a resource**
   - Search for "Web App"
   - Click **Create**

3. **Select Your Subscription**
   - Choose your Azure subscription from the dropdown

4. **Configure Resource Group**
   - Select an existing resource group or create a new one (e.g., `1fe-demo-rg`)

5. **Set Web App Name**
   - Enter a globally unique name for your web app (e.g., `1fe-demo`)

6. **Configure Publishing Method**
   - **Publish**: Select `Code`

7. **Select Runtime Stack**
   - **Runtime stack**: Select the appropriate runtime (e.g., `Node 22-LTS`)

8. **Choose Operating System**
   - **Operating System**: Select `Linux`

9. **Select Region**
   - **Region**: Select a region close to your users (e.g., `Central US`)

10. **Proceed to Deployment Configuration**
    - Click **Next: Deployment** to continue

:::note[Important: Web App URL]
The name you choose will be part of the default URL (e.g., `1fe-demo.azurewebsites.net`). Choose a descriptive and globally unique name.
:::

#### Step 3: Configure Deployment from GitHub

This section details how to enable continuous deployment from a GitHub repository, so that every time you push a change, your web app is automatically updated.

**Setup Instructions:**

1. **Navigate to Deployment Tab**
   - On the **Deployment** tab during Web App creation (or by navigating to Deployment Center for an existing app)

2. **Enable Continuous Deployment**
   - Set **Continuous deployment** to `Enable`

3. **Select GitHub as Source**
   - **Source**: Select `GitHub`

4. **Authorize Azure to Access GitHub**
   - You may need to authorize Azure to access your GitHub account
   - Follow the prompts to sign in to GitHub

5. **Grant Necessary Permissions**
   - Grant the necessary permissions when prompted

6. **Select Your GitHub Organization**
   - **Organization**: Select your GitHub organization from the dropdown

7. **Choose Your Repository**
   - **Repository**: Select the repository containing your application code

8. **Select Deployment Branch**
   - **Branch**: Select the branch you want to deploy from (e.g., `main` or `production`)

9. **Review and Create Web App**
   - Click **Review + create** to review all settings

10. **Complete Web App Creation**
    - Click **Create** to create the Web App
    - Azure will automatically generate a GitHub Actions workflow file in your repository to handle deployments

**Official Documentation:** [Deploy to Azure App Service using GitHub Actions](https://docs.microsoft.com/en-us/azure/app-service/deploy-github-actions)

#### Step 4: Add and Configure a Custom Domain

Your Web App has a default domain (e.g., `1fe-demo.azurewebsites.net`), but you will likely want to use a custom domain.

**Setup Instructions:**

1. **Navigate to Your Web App Resource**
   - In the Azure Portal, navigate to your Web App resource

2. **Access Custom Domains Section**
   - In the left-hand menu, select **Custom domains**

3. **Start Adding Custom Domain**
   - Click **+ Add custom domain**

4. **Select Your DNS Provider**
   - **Domain provider**: Select your DNS provider (e.g., GoDaddy, Cloudflare)

5. **Enter Your Domain Name**
   - Enter the domain name you want to use (e.g., `demo.yourdomain.com`)

6. **Review DNS Record Requirements**
   - The portal will provide you with DNS record information to validate ownership

7. **Create Required DNS Records**
   - You will need to create a TXT and/or a CNAME record with your domain registrar
   - Use the DNS information provided by Azure

8. **Validate Domain Ownership**
   - Once the DNS records are created, click **Validate** in the Azure Portal

9. **Complete Domain Addition**
   - After validation is successful, click **Add custom domain**

:::important[App Service Plan Requirement]
Your App Service plan must be a paid tier (e.g., Basic, Standard, Premium) to add a custom domain. The Free (F1) and Shared (D1) tiers do not support custom domains.
:::

**Official Documentation:** [Set up an existing custom domain name for your app](https://docs.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-custom-domain)

#### Step 5: Configure Environment Variables

Environment variables (known as "Application settings" in Azure) are a secure way to manage configuration values, such as API keys or database connection strings, without hard-coding them into your application.

**Setup Instructions:**

1. **Navigate to Your Web App Resource**
   - In the Azure Portal, navigate to your Web App resource

2. **Access Configuration Section**
   - In the left-hand menu, select **Configuration**

3. **Open Application Settings Tab**
   - On the **Application settings** tab, click **+ New application setting**

4. **Enter Variable Name**
   - Enter the **Name** for your environment variable

5. **Enter Variable Value**
   - Enter the **Value** for your environment variable

6. **Confirm Variable Addition**
   - Click **OK** to confirm the new setting

7. **Save Configuration Changes**
   - Click **Save** at the top of the page

8. **Wait for App Restart**
   - The app will restart automatically to apply the new settings

9. **Handle Nested JSON Configuration (If Needed)**
   - For nested JSON keys (e.g., `Logging:LogLevel:Default`)
   - Replace the colons (`:`) with double underscores (`__`) in the name
   - Example: `Logging__LogLevel__Default`

:::caution[App Restart Required]
The app will restart automatically when you save new application settings. Plan configuration changes during appropriate maintenance windows.
:::

**Official Documentation:** [Configure an App Service App - Environment variables](https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings)

## Environment Configuration

### Multiple Environments Setup

**Development Environment:**
- Use branch-based deployments (e.g., `dev` branch)
- Connect to development CDN endpoints
- Point to development configuration service
- Enable debug mode and verbose logging

**Staging Environment:**
- Deploy from `staging` branch or pre-release tags
- Use staging CDN and configuration endpoints
- Mirror production setup for accurate testing
- Enable performance monitoring

**Production Environment:**
- Deploy from `main`/`master` branch or release tags
- Use production CDN and configuration services
- Implement deployment approval workflows
- Enable comprehensive monitoring and alerting

:::important[Environment Isolation]
Always use separate hosting instances and environment variables for different environments. This prevents accidental deployments and maintains proper isolation.
:::

### Domain Configuration

**Subdomain Strategy:**
- `dev.yourapp.com` - Development environment
- `staging.yourapp.com` - Staging environment  
- `yourapp.com` - Production environment

**Environment Variables:**
```bash
# Development
REACT_APP_API_URL=https://api-dev.yourapp.com
REACT_APP_CDN_URL=https://cdn-dev.yourapp.com
REACT_APP_ENV=development

# Production
REACT_APP_API_URL=https://api.yourapp.com
REACT_APP_CDN_URL=https://cdn.yourapp.com
REACT_APP_ENV=production
```

## Security Considerations

### HTTPS Configuration

**SSL/TLS Requirements:**
- Always use HTTPS in production environments
- Configure HSTS (HTTP Strict Transport Security) headers
- Use secure cookie settings for any authentication
- Implement proper CSP (Content Security Policy) headers

**Security Headers:**
```
Content-Security-Policy: default-src 'self' https://your-cdn.com
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

### Access Controls

**Environment Protection:**
- Implement authentication for non-production environments
- Use IP whitelisting for staging environments
- Set up proper CORS policies for API access
- Monitor and log all access attempts

**Deployment Security:**
- Use secure CI/CD pipelines with proper secrets management
- Implement code signing and integrity checks
- Enable audit logging for all deployments
- Use least-privilege access principles

## Monitoring and Observability

### Essential Monitoring

**Uptime Monitoring:**
- Monitor application availability across multiple regions
- Set up alerts for downtime or performance degradation
- Track response times and error rates
- Monitor SSL certificate expiration

**Performance Monitoring:**
- Page load times and Core Web Vitals
- JavaScript error tracking and reporting
- API response times and error rates
- CDN cache hit ratios and performance

**User Analytics:**
- User behavior and journey tracking
- Feature usage and adoption metrics
- Performance impact on user experience
- Geographic distribution of users

## Deployment Automation

### CI/CD Integration

**CI/CD Configuration:**

For complete GitHub Actions workflows, deployment configurations, and automation examples, refer to the [1fe-ci-cd repository](https://github.com/docusign/1fe-ci-cd) which contains production-ready CI/CD templates and best practices.

### Deployment Best Practices

**Progressive Deployment:**
- Deploy to staging environment first
- Run automated tests and health checks
- Gradually roll out to production users
- Monitor metrics and rollback if needed

**Health Checks:**
- Implement application health endpoints
- Verify core functionality after deployment
- Check integration with external services
- Monitor error rates and performance metrics

## Troubleshooting Common Issues

### Build Failures

**Environment Variables:**
- Verify all required environment variables are set
- Check for differences between local and production environments
- Ensure secrets are properly configured in hosting platform

**Dependency Issues:**
- Check Node.js version compatibility
- Verify package.json and lock file consistency
- Clear cache and reinstall dependencies if needed

### Runtime Issues

**404 Errors (SPA Routing):**
- Configure hosting platform to serve index.html for all routes
- Set up proper redirect rules for single-page applications
- Check that client-side routing is properly configured

**CORS Errors:**
- Configure API servers to allow requests from your domain
- Set up proper CORS headers on backend services
- Check that environment-specific API URLs are correct

**Performance Issues:**
- Optimize bundle size and implement code splitting
- Configure proper caching headers
- Ensure CDN is properly configured for static assets

## Next Steps

After setting up hosting:
1. [Configure CDN for Widget Bundles](/infrastructure/cdn-setup/)
2. [Set up Configuration Service](/infrastructure/configuration-setup/)
3. [Set up NPM Registry](/infrastructure/npm-registry-setup/)
4. [Implement CI/CD Integration](/platform-guides/project-setup/)