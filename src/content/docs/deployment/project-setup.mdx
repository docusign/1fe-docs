
---
title: Setting Up a Self-Contained CI/CD Pipeline
description: This guide provides a complete checklist and step-by-step instructions for integrating a project repository with a self-contained CI/CD pipeline. The pipeline's logic resides entirely within the project repository, making it portable and easy to manage.
sidebar:
  order: 2
---

import { FcEngineering } from 'react-icons/fc';

### <FcEngineering style={{ display: 'inline', marginRight: '0.5rem', verticalAlign: 'middle' }} /> How do I production-ize my widget?

### Architecture:
- **Self-Contained Pipeline:** All workflow logic is located within the project repository, making it a single source of truth for CI/CD configuration
- **GitHub Actions:** The automation platform used to automate build, test, and deployment jobs
- **GitHub Secrets & Environments:** Secure storage for credentials and manual approval gates

## 1. GitHub Repository Configuration

This is a critical administrative step that must be completed to enable CI/CD. It involves configuring secrets, environments, and permissions on your GitHub repository.

### 1.1 Configure Repository Secrets

These secrets are essential for workflows to authenticate with external services. They must be securely stored as repository secrets, not hardcoded in files.

1. In your GitHub repository, navigate to **Settings > Secrets and variables > Actions**
2. Click on **New repository secret**
3. Create the following secrets (contact the DevOps team or project maintainers to obtain the values):

| Secret Name | Purpose |
|-------------|---------|
| `PRIVATE_KEY_FOR_1FE` | Authentication: An SSH private key for authenticating with the private 1fe repository to fetch dependencies during yarn install |
| `PRIVATE_KEY_FOR_WIDGET_BASE_CONFIG` | Authentication: An SSH private key for authenticating with the private widget base configuration repository |
| `AKAMAI_NS_SSH_PRIVATE_KEY` | Deployment: An SSH private key for securely uploading compiled artifacts to the Akamai CDN |
| `AZURE_APP_CONFIG_CONNECTION_STRING` | Deployment: The connection string for the Azure App Configuration instance, used to update widget versions in a key-value store |

:::danger[Important Security Note]
**NEVER** expose these secret values in your workflow YAML files or commit them to the repository.
:::

### 1.2 Configure Deployment Environments

GitHub Environments are used to manage deployment rules and approvals. You will configure two environments:

1. In your repository, navigate to **Settings > Environments**

#### Create the `integration` Environment

1. Click **New environment** and provide the name `integration`
2. Leave all deployment protection rules disabled (this environment is for automated CI/CD deployments)
3. Click **Configure environment** to save

#### Create the `production-release` Environment

1. Click **New environment** and provide the name `production-release`
2. Under **Deployment protection rules**, enable the **Required reviewers** rule
3. Add the teams or individuals (e.g., the core maintainer team) who are responsible for approving a production deployment
4. Click **Save**

### 1.3 Set Default Workflow Permissions

The `GITHUB_TOKEN` provided to your workflows needs write access to perform actions like creating tags and amending commits.

1. In your repository, navigate to **Settings > Actions > General**
2. Scroll down to the **Workflow permissions** section
3. Ensure that **Read and write permissions** is selected (required for workflows to use the `GITHUB_TOKEN` to push code or create tags)
4. Click **Save**

## 2. Add Self-Contained Workflow Files

Now you will add all the necessary CI/CD workflow YAML files to your repository. These files are designed to call each other using relative paths, making the entire pipeline self-contained.

1. Create the `.github/workflows` directory in your repository's root if it does not exist
2. Add the following files to this directory:

### Workflow Files Overview

| File Name | Purpose |
|-----------|---------|
| `ci-widgets.yml` | Main orchestrator workflow - entry point for your entire CI/CD pipeline, coordinating all build, test, and deploy jobs |
| `reusable-widget-build.yml` | Contains the logic for building the widget, calculating its version, and archiving the build artifact |
| `reusable-widget-test.yml` | Contains all test jobs (lint, unit, contract, E2E) |
| `reusable-widget-upload-akamai.yml` | Handles uploading the widget build artifact to the Akamai CDN |
| `reusable-git-ops.yml` | Performs Git operations like committing version updates and creating release tags |
| `reusable-update-azure-config.yml` | Updates the widget version key in Azure App Configuration |
| `reusable-rollback-ci.yml` | Orchestrates the rollback process, checking for a valid asset on the CDN before updating the Azure configuration |
| `rollback-widget.yml` | Top-level trigger file for manual rollbacks |

## 3. Commit, Push, and Activate the Workflows

Commit the new workflow files and push them to your repository's main branch. This will automatically activate them and make them visible in the Actions tab of your repository.

```bash
git add .github/workflows/
git commit -m "feat: Add self-contained CI/CD workflows"
git push origin main
```

## 4. Trigger and Monitor the Pipelines

Your repository is now fully configured. You can monitor automatic runs and trigger manual ones from the GitHub UI.

### To Trigger the Main CI/CD Pipeline

**Automatic Runs:** A push to the `main` or `feature/**` branches, or a `pull_request` to `main`, will automatically trigger the main CI/CD pipeline.

**Manual Trigger:**
1. Go to the **Actions** tab
2. Select **"Widget CI Pipeline"** from the list
3. Click **"Run workflow"**

### To Trigger a Rollback

This workflow is for manual use only via the `workflow_dispatch` trigger.

1. Go to the **Actions** tab
2. Select **"Rollback Widget"** from the list
3. Click the **"Run workflow"** dropdown
4. Enter the `target-version` and select the environment from the dropdown
5. Click **"Run workflow"**

:::tip[Monitoring]
All run logs, status, and artifacts will be available in the GitHub Actions tab for monitoring and debugging.
:::